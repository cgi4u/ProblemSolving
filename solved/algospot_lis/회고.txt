문제의 난이도에 비해 너무 뻘짓을 많이했다.
케이스를 다음과 같이 나눠야 했다.

A: 현재 숫자 포함 최대 길이
이전에 나왔던 현재 숫자보다 작은 숫자까지의 '해당 숫자 포함' 최대 순열 길이 중 가장 긴 것 + 1
비포함까지 들어가면 현재 숫자보다 큰 숫자가 나오는 순열이 포함되어 버릴 수 있고, 어차피 현재 숫자보다 작은 숫자로만 구성된 부순열이어야 하므로,
무조건 해당 수를 포함한게 비포함한거보다 크다.
B: 현재 숫자 비포함 최대 길이
그냥 이전 숫자까지의 최대길이. 이건 따로 배열을 만들 필요도 없고 그냥 변수 한개에 저장해서 더 커질때만 갱신하면 된다.

즉 저장해야 할 것은 각 수까지의 '해당 숫자 포함 최대 순열 길이'다.

1. 초기에는 각 숫자에서의 최대 수열 길이만 저장했다. 이 경우 당연히 최대 수열 길이가 누적되기만 하고, 위에 썼든 더 큰 숫자가 나오는 순열을 앞에 붙여버릴 수 있기 때문에 틀리다.

2. 포함 최대 길이로 바꿧지만 조건이 틀렸다. 
현재 숫자보다 작은 '가장 큰 인덱스를 가진' 수를 선택했는데 가장 큰 인덱스를 가진 수가 가장 긴 부분순열을 갖는다는 보장은 없다.
그 다음으로는 현재 숫자보다 큰 '가장 큰'수를 선택하려고 했는데 이것도 틀리다. 1 2 100 1 2 3 4 5 6 7 8의 경우 100을 골라버린다.
즉 답은 그냥 '자기보다 작은 수 중 가장 큰 자기 포함 순열의 길이' + 1이다. 그냥 다 조사해야한다.

3. 2를 시도한 다음 포함 최대 길이 저장하는게 틀린 줄 알고 1로 바꾸는 어이없는 실수를 저질렀다. 
실제로는 최대인덱스를 찾으려고 한게 틀린거였다. 틀릴 때일수록 조건을 더 정확히 따져봐야 한다.
