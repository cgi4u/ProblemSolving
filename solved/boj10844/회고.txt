1. 처음에는 단순히 떠올릴 수 있는 대로 재귀식으로 생각해서 1부터 9까지 재귀함수를 호출한 뒤 그 반환 값을 다 더하는 식으로 생각.
당연히 시간초과. queue를 사용하는 방식으로 변경했으나 본질적으로 알고리즘이 바뀌지는 않고 오히려 이쪽은 메모리초과.

2. 길이가 N+1인 계단수는 길이가 N인 계단수 앞에 수 하나를 붙인 것일 수 밖에 없고,
길이가 N인 계단수는 0~9로 시작하는 10가지로 분류할 수 있으므로, 길이가 1인 계단수부터 구해서 차례대로 더해나가는 방식 착안 (동적프로그래밍)
앞자리가 0인 수는 고려하지 않지만 중간 계산단계에서는 필요하므로 계산해 놓았다가 최종 합산때만 포함하지 않기로 함

3. 길이가 n+1이고 자리 숫자가 a인 계단수의 수 = 
	길이가 n이고 자리 숫자가 a-1인 계단수의 수(단, a > 0일 때만)
	+ 길이가 n이고 자리 숫자가 a+1인 계단수의 수(단, a < 9일 때만)
길이 1일때 개수 1로 초기화하고 길이 2~N에 대해 위 식을 반복하면 구할 수  있음.

4.마지막에 1000000000으로 나머지를 내는 부분에서 중간에만 나머지식을 넣고 마지막엔 안넣었다가 오버플로우가 생긴걸 오래 지체함
짠 코드에 대해 잘 기억하고 파악하고 있을 필요가 있음. 정 안되면 한 부분에 집착하기보다 코드 전체를 다시 한번 보는게 좋을 수 있음.

추가: (a + b) % x != a % x + b % x
이유는 a = xi + j, b= xk + l일 때 전자는 (j+l) % 고 후자는 j+l 이기 때문.
(a + b) % x로 한다면 a + b에서 오버플로우가 발생할 가능성이 없는 한 오버플로우가 발생하지 않음.